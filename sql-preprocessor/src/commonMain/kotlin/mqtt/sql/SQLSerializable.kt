package mqtt.sql

import kotlin.reflect.KClass
import kotlin.reflect.KProperty


inline fun <reified Annotation : kotlin.Annotation> findMemberWithAnnotationOf(type: KClass<*>): String? {
    var primaryKey: String? = null
    for (member in type.members) {
        for (annotation in member.annotations) {
            if (annotation is Annotation) {
                primaryKey = member.name
                break
            }
        }
        if (primaryKey != null) {
            break
        }
    }
    return primaryKey
}

@ExperimentalUnsignedTypes
fun createSimpleRelationship(parent: KClass<*>): List<String> {
    // create
    createTable(parent)
    // update
    // delete
    delete("")
    // delete trigger
}

@ExperimentalUnsignedTypes
inline fun <reified Parent : Any> createTableInheritence(vararg childTables: KClass<*>)
        : List<CharSequence> {
    val parentClass = Parent::class
    // +1 for parent
    val tables = ArrayList<CharSequence>(childTables.size + 1)
    tables += createTable(parentClass)
    val primaryKey: String? = findMemberWithAnnotationOf<PrimaryKey>(parentClass)
    val childTriggers = HashMap<KClass<*>, String>(childTables.size)
    val deletes = HashMap<KClass<*>, String>(childTables.size)
    if (primaryKey != null) {
        deletes[parentClass] = delete(primaryKey, parentClass.qualifiedName!!)
    }
    childTables.forEach {
        tables += createTable(it)
        if (primaryKey != null) {
            val foreignKey = findMemberWithAnnotationOf<ForeignKey>(it)
            if (foreignKey != null) {
                childTriggers[it] = foreignKey
                deletes[it] = delete(foreignKey, it.qualifiedName!!)
            }
        }
    }
    if (primaryKey != null) {
        deletes.values.forEach {
            tables += it
        }
        createChildMappingDeleteTrigger(parentClass, primaryKey, childTriggers).forEach {
            tables += it
        }
    }
    return tables
}

@ExperimentalUnsignedTypes
fun <T : Any> createTable(
    type: KClass<T>,
    customClasses: (KProperty<*>) -> CharSequence? = { null },
    nativeClasses: (KProperty<*>) -> CharSequence? = { null }
): CharSequence {
    val members = type.members
        .filter { it is KProperty }

    val annotationsMap = type.getAnnotationsIncludingSuperclass()

    val annotatationsOnClass = annotationsMap[""]
    var tableName = type.qualifiedName
    if (annotatationsOnClass != null) {
        for (annotation in annotatationsOnClass) {
            if (annotation is SQLTable) {
                if (annotation.tableName.isNotEmpty()) {
                    tableName = annotation.tableName
                }
            }
        }
    }
    val foreignKeys = LinkedHashMap<String, ForeignKey>()\
    val sql = StringBuilder("CREATE TABLE '$tableName'(\n")

    val spacer = ' '
    var hasPrimaryKey = false
    var hasForeignKey = false
    for (member in members) {
        for (annotation in member.annotations) {
            if (annotation is PrimaryKey) {
                hasPrimaryKey = true
            } else if (annotation is ForeignKey) {
                hasForeignKey = true
            }
            if (hasForeignKey && hasPrimaryKey) {
                break
            }
        }
        if (hasForeignKey && hasPrimaryKey) {
            break
        }
    }
    if (!hasForeignKey && !hasPrimaryKey) {
        sql.append(spacer)
        sql.append("`autogenerated_sql_id` INTEGER AUTOINCREMENT NOT NULL PRIMARY KEY,\n")
    }
    members.forEachIndexed { index, it ->
        val property = it as KProperty<*>
        val classifier = property.returnType.classifier!!
        val returnType = customClasses(property) ?: when (classifier) {
            Boolean::class -> "BIT(1)"
            Byte::class -> "TINYINT"
            UByte::class -> "TINYINT UNSIGNED"
            Short::class -> "SMALLINT"
            UShort::class -> "SMALLINT UNSIGNED"
            Int::class -> "INT"
            UInt::class -> "INT UNSIGNED"
            Long::class -> "BIGINT"
            ULong::class -> "BIGINT UNSIGNED"
            Char::class -> "CHARACTER"
            Float::class -> "FLOAT"
            Double::class -> "DOUBLE"
            Number::class -> "TEXT" // This could be a BigInteger that isn't supported by implementations of SQL
            String::class, CharSequence::class -> "TEXT"
            ByteArray::class, UByteArray::class -> "BLOB"
            else -> nativeClasses(property) ?: property.returnType.toString() // BLOB AKA NONE
        }
        sql.append(spacer)
        if (SQLITE_KEY_WORDS.contains(it.name.toUpperCase())) {
            sql.append("`${it.name}` $returnType")
        } else {
            sql.append("${it.name} $returnType")
        }
        val annotations = annotationsMap[it.name] ?: emptyList()
        if (!it.returnType.isMarkedNullable) {
            if (sql[sql.lastIndex] != spacer) {
                sql.append(spacer)
            }
            sql.append("NOT NULL")
        }
        val isPrimaryKey = annotations.findInstanceOf<PrimaryKey>() != null
        if (isPrimaryKey) {
            if (sql[sql.lastIndex] != spacer) {
                sql.append(spacer)
            }
            sql.append("PRIMARY KEY")
            hasPrimaryKey = true
        }
        if (annotations.findInstanceOf<Unique>() != null) {
            if (sql[sql.lastIndex] != spacer) {
                sql.append(spacer)
            }
            sql.append("UNIQUE")
        }
        val checkConstraint = annotations.findInstanceOf<Check>()
        if (checkConstraint is Check) {
            if (sql[sql.lastIndex] != spacer) {
                sql.append(' ')
            }
            sql.append("CHECK(${checkConstraint.expression})")
        }
        val foreignKey = annotations.findInstanceOf<ForeignKey>()
        if (foreignKey is ForeignKey) {
            foreignKeys[it.name] = foreignKey
        }
        val isNotLast = index < members.size - 1
        if (foreignKeys.isNotEmpty() || isNotLast) {
            sql.append(",\n")
        } else {
            sql.append("\n")
        }
    }


    val lastKey = foreignKeys.keys.lastOrNull()
    for ((childColumn, parent) in foreignKeys) {
        sql.append("${spacer}FOREIGN KEY($childColumn) REFERENCES `${parent.table.qualifiedName}`(${parent.column})")
        if (parent.onDelete != ForeignKeyActions.NoAction) {
            sql.append(" ON DELETE ${parent.onDelete.action}")
        }
        if (parent.onUpdate != ForeignKeyActions.NoAction) {
            sql.append(" ON UPDATE ${parent.onUpdate.action}")
        }
        val isLast = childColumn == lastKey
        if (isLast) {
            sql.append('\n')
        } else {
            sql.append(",\n")
        }
    }
    sql.append(");")
    return sql
}

inline fun <reified T> insertInto(tableName: String? = T::class.qualifiedName): CharSequence {
    val sql = StringBuilder("INSERT INTO '$tableName' VALUES(")
    val members = T::class.members
        .filter { it is KProperty }
    members.forEachIndexed { index, it ->
        val wrapInSingleQuote = it.returnType.classifier == String::class
        if (wrapInSingleQuote) sql.append('\'')
        sql.append("\${${it.name}}")
        if (wrapInSingleQuote) sql.append('\'')
        if (index < members.size - 1) sql.append(", ")
    }
    sql.append(");")
    return sql
}

inline fun <reified Parent : Any, reified Child : Any> createView(
    parentTable: KClass<Parent>,
    parentColumn: String,
    parentSortChild: String,
    childTable: KClass<Child>,
    childColumn: String,
    limit: Int = 1
): CharSequence {
    val parentTableName = parentTable.qualifiedName
    val childTableName = childTable.qualifiedName
    val viewName = "`${parentTableName}_$childTableName`"
    return """
        CREATE VIEW $viewName AS 
        SELECT `$parentTableName`.$parentColumn, `$childTableName`.*
        FROM `$parentTableName`
        INNER JOIN `$childTableName` ON `$parentTableName`.$parentColumn = `$childTableName`.$childColumn
        ORDER BY `$parentTableName`.$parentSortChild
        LIMIT $limit;
    """.trimIndent()
}

inline fun <reified Parent : Any> createChildMappingDeleteTrigger(
    parentTable: KClass<Parent> = Parent::class,
    parentColumn: String,
    childTables: Map<KClass<*>, String>
): List<CharSequence> {
    val childDeleteTriggers = ArrayList<CharSequence>(childTables.size)
    for ((childClass, childColumn) in childTables) {
        childDeleteTriggers += createChildDeleteTrigger(
            parentTable,
            parentColumn,
            childClass.qualifiedName!!,
            childColumn
        )
    }
    return childDeleteTriggers
}


inline fun <reified Parent : Any> createChildDeleteTrigger(
    parentTable: KClass<Parent> = Parent::class,
    parentColumn: String,
    childTable: String,
    childColumn: String
): CharSequence {
    val parentTableName = parentTable.qualifiedName
    return """
        CREATE TRIGGER `$childTable.${childColumn}_DELETE_FROM_QUEUED` BEFORE DELETE ON `$childTable`
        BEGIN
         DELETE FROM `$parentTableName` WHERE `$parentColumn` = OLD.`$childColumn`;
        END;
    """.trimIndent()
}


fun delete(propertyName: String, tableName: String) =
    "DELETE FROM '$tableName' WHERE $propertyName = '\${$propertyName}';"

inline fun <reified T> List<Annotation>.findInstanceOf(): Annotation? {
    for (annotation in this) {
        if (annotation is T) {
            return annotation
        }
    }
    return null
}

fun KClass<*>.getAnnotationsIncludingSuperclass(): Map<String, List<Annotation>> {
    val map = getMemberAnnotations()
    for (it in supertypes) {
        if (it.classifier == Any::class) {
            continue
        }
        val superMap = (it.classifier as KClass<*>).getAnnotationsIncludingSuperclass()
        map.safeAdd(superMap)
    }
    return map
}

fun MutableMap<String, MutableList<Annotation>>.safeAdd(other: Map<String, List<Annotation>>) {
    for ((key, values) in other) {
        val list = get(key) ?: ArrayList()
        list.addAll(values)
        if (list.isNotEmpty())
            this[key] = list
    }
}


fun KClass<*>.getMemberAnnotations(): MutableMap<String, MutableList<Annotation>> {
    val map = HashMap<String, MutableList<Annotation>>()
    if (annotations.isNotEmpty()) {
        map[""] = annotations.toMutableList()
    }
    constructors.forEach { constructor ->
        constructor.parameters.forEach { param ->
            val name = param.name!!
            val list = if (!map.containsKey(name)) {
                val listLocal = ArrayList<Annotation>()
                map[name] = listLocal
                listLocal
            } else {
                map[name]!!
            }
            list += param.annotations
            if (map[name]?.isEmpty() == true) {
                map.remove(name)
            }
        }
    }
    val members = members
    for (memberUnchecked in members) {
        val member = memberUnchecked as? KProperty<*> ?: continue
        val name = member.name
        val annotations = member.annotations
        if (annotations.isEmpty()) {
            continue
        }
        val list = if (!map.containsKey(name)) {
            val listLocal = ArrayList<Annotation>()
            map[name] = listLocal
            listLocal
        } else {
            map[name]!!
        }
        list += annotations
    }
    return map
}

fun KClass<*>.printAnnotations(prefix: String = "") {
    println("$this $prefix\nclass annotations ${this.annotations}")
    constructors.forEach {
        if (it.parameters[0].annotations.isNotEmpty()) {
            println("constructor annotation ${it.parameters[0].annotations}")
        }
    }
    val memberAnnotations = HashMap<String, ArrayList<Annotation>>()
    members.forEach { member ->
        val list = ArrayList<Annotation>()
        memberAnnotations[member.name] = list
        member.annotations.forEach { annotation ->
            list.add(annotation)
        }
        if (list.isEmpty()) {
            memberAnnotations.remove(member.name)
        }
    }
    if (memberAnnotations.isEmpty()) {
        return
    }
    println("member annotations $memberAnnotations\n\n")
}

annotation class PrimaryKey



annotation class Meow
annotation class Meow2


val SQLITE_KEY_WORDS = setOf(
    "ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "ANALYZE", "AND", "AS", "ASC", "ATTACH",
    "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN",
    "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME",
    "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", "DESC", "DETACH", "DISTINCT",
    "DO", "DROP", "EACH", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDE", "EXCLUSIVE", "EXISTS", "EXPLAIN", "FAIL",
    "FILTER", "FOLLOWING", "FOR", "FOREIGN", "FROM", "FULL", "GLOB", "GROUP", "GROUPS", "HAVING", "IF", "IGNORE",
    "IMMEDIATE", "IN", "INDEX", "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IS",
    "ISNULL", "JOIN", "KEY", "LEFT", "LIKE", "LIMIT", "MATCH", "NATURAL", "NO", "NOT", "NOTHING", "NOTNULL", "NULL",
    "OF", "OFFSET", "ON", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARTITION", "PLAN", "PRAGMA", "PRECEDING",
    "PRIMARY", "QUERY", "RAISE", "RANGE", "RECURSIVE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME",
    "REPLACE", "RESTRICT", "RIGHT", "ROLLBACK", "ROW", "ROWS", "SAVEPOINT", "SELECT", "SET", "TABLE", "TEMP",
    "TEMPORARY", "THEN", "TIES", "TO", "TRANSACTION", "TRIGGER", "UNBOUNDED", "UNION", "UNIQUE", "UPDATE", "USING",
    "VACUUM", "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW", "WITH", "WITHOUT"
)
